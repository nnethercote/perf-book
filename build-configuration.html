<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Build Configuration - The Rust Performance Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Performance Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/nnethercote/perf-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/nnethercote/perf-book/edit/master/src/build-configuration.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="build-configuration"><a class="header" href="#build-configuration">Build Configuration</a></h1>
<p>You can drastically change the performance of a Rust program without changing
its code, just by changing its build configuration. There are many possible
build configurations for each Rust program. The one chosen will affect several
characteristics of the compiled code, such as compile times, runtime speed,
memory use, binary size, debuggability, profilability, and which architectures
your compiled program will run on.</p>
<p>Most configuration choices will improve one or more characteristics while
worsening one or more others. For example, a common trade-off is to accept
worse compile times in exchange for higher runtime speeds. The right choice
for your program depends on your needs and the specifics of your program, and
performance-related choices (which is most of them) should be validated with
benchmarking.</p>
<p>It is worth reading this chapter carefully to understand all the build
configuration choices. However, for the impatient or forgetful,
<a href="https://github.com/Kobzol/cargo-wizard"><code>cargo-wizard</code></a> encapsulates this information and can help you choose an
appropriate build configuration.</p>
<p>Note that Cargo only looks at the profile settings in the <code>Cargo.toml</code> file at
the root of the workspace. Profile settings defined in dependencies are
ignored. Therefore, these options are mostly relevant for binary crates, not
library crates.</p>
<h2 id="release-builds"><a class="header" href="#release-builds">Release Builds</a></h2>
<p>The single most important build configuration choice is simple but <a href="https://users.rust-lang.org/t/why-my-rust-program-is-so-slow/47764/5">easy to
overlook</a>: make sure you are using a <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#release">release build</a> rather than a <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#dev">dev build</a>
when you want high performance. This is usually done by specifying the
<code>--release</code> flag to Cargo.</p>
<p>Dev builds are the default. They are good for debugging, but are not optimized.
They are produced if you run <code>cargo build</code> or <code>cargo run</code>. (Alternatively,
running <code>rustc</code> without additional options also produces an unoptimized build.)</p>
<p>Consider the following final line of output from a <code>cargo build</code> run.</p>
<pre><code class="language-text">Finished dev [unoptimized + debuginfo] target(s) in 29.80s
</code></pre>
<p>This output indicates that a dev build has been produced. The compiled code
will be placed in the <code>target/debug/</code> directory. <code>cargo run</code> will run the dev
build.</p>
<p>In comparison, release builds are much more optimized, omit debug assertions
and integer overflow checks, and omit debug info. 10-100x speedups over dev
builds are common! They are produced if you run <code>cargo build --release</code> or
<code>cargo run --release</code>. (Alternatively, <code>rustc</code> has multiple options for
optimized builds, such as <code>-O</code> and <code>-C opt-level</code>.) This will typically take
longer than a dev build because of the additional optimizations.</p>
<p>Consider the following final line of output from a <code>cargo build --release</code> run.</p>
<pre><code class="language-text">Finished release [optimized] target(s) in 1m 01s
</code></pre>
<p>This output indicates that a release build has been produced. The compiled code
will be placed in the <code>target/release/</code> directory. <code>cargo run --release</code> will
run the release build.</p>
<p>See the <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo profile documentation</a> for more details about the differences
between dev builds (which use the <code>dev</code> profile) and release builds (which use
the <code>release</code> profile).</p>
<p>The default build configuration choices used in release builds provide a good
balance between the abovementioned characteristics such as compile times, runtime
speed, and binary size. But there are many possible adjustments, as the
following sections explain.</p>
<h2 id="maximizing-runtime-speed"><a class="header" href="#maximizing-runtime-speed">Maximizing Runtime Speed</a></h2>
<p>The following build configuration options are designed primarily to maximize
runtime speed. Some of them may also reduce binary size.</p>
<h3 id="codegen-units"><a class="header" href="#codegen-units">Codegen Units</a></h3>
<p>The Rust compiler splits crates into multiple <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#codegen-units">codegen units</a> to parallelize
(and thus speed up) compilation. However, this might cause it to miss some
potential optimizations. You may be able to improve runtime speed and reduce
binary size, at the cost of increased compile times, by setting the number of
units to one. Add these lines to the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[profile.release]
codegen-units = 1
</code></pre>
<!-- Using `https` for this link triggers "potential security risk" warnings due
to a certificate problem. -->
<p><a href="http://likebike.com/posts/How_To_Write_Fast_Rust_Code.html#emit-asm"><strong>Example 1</strong></a>,
<a href="https://github.com/rust-lang/rust/pull/115554#issuecomment-1742192440"><strong>Example 2</strong></a>.</p>
<h3 id="link-time-optimization"><a class="header" href="#link-time-optimization">Link-time Optimization</a></h3>
<p><a href="https://doc.rust-lang.org/cargo/reference/profiles.html#lto">Link-time optimization</a> (LTO) is a whole-program optimization technique that
can improve runtime speed by 10-20% or more, and also reduce binary size, at
the cost of worse compile times. It comes in several forms.</p>
<p>The first form of LTO is <em>thin local LTO</em>, a lightweight form of LTO. By
default the compiler uses this for any build that involves a non-zero level of
optimization. This includes release builds. To explicitly request this level of
LTO, put these lines in the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[profile.release]
lto = false
</code></pre>
<p>The second form of LTO is <em>thin LTO</em>, which is a little more aggressive, and
likely to improve runtime speed and reduce binary size while also increasing
compile times. Use <code>lto = "thin"</code> in <code>Cargo.toml</code> to enable it.</p>
<p>The third form of LTO is <em>fat LTO</em>, which is even more aggressive, and may
improve performance and reduce binary size further (but <a href="https://github.com/rust-lang/rust/pull/103453">not always</a>) while
increasing build times again. Use <code>lto = "fat"</code> in <code>Cargo.toml</code> to enable it.</p>
<p>Finally, it is possible to fully disable LTO, which will likely worsen runtime
speed and increase binary size but reduce compile times. Use <code>lto = "off"</code> in
<code>Cargo.toml</code> for this. Note that this is different to the <code>lto = false</code> option,
which, as mentioned above, leaves thin local LTO enabled.</p>
<h3 id="alternative-allocators"><a class="header" href="#alternative-allocators">Alternative Allocators</a></h3>
<p>It is possible to replace the default (system) heap allocator used by a Rust
program with an alternative allocator. The exact effect will depend on the
individual program and the alternative allocator chosen, but large improvements
in runtime speed and large reductions in memory usage have been seen in
practice. The effect will also vary across platforms, because each platform’s
system allocator has its own strengths and weaknesses. The use of an
alternative allocator is also likely to increase binary size and compile times.</p>
<h4 id="jemalloc"><a class="header" href="#jemalloc">jemalloc</a></h4>
<p>One popular alternative allocator for Linux and Mac is <a href="https://github.com/jemalloc/jemalloc">jemalloc</a>, usable via
the <a href="https://crates.io/crates/tikv-jemallocator"><code>tikv-jemallocator</code></a> crate. To use it, add a dependency to your
<code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
tikv-jemallocator = "0.5"
</code></pre>
<p>Then add the following to your Rust code, e.g. at the top of <code>src/main.rs</code>:</p>
<pre><code class="language-rust ignore">#[global_allocator]
static GLOBAL: tikv_jemallocator::Jemalloc = tikv_jemallocator::Jemalloc;</code></pre>
<p>Furthermore, on Linux, jemalloc can be configured to use <a href="https://www.kernel.org/doc/html/next/admin-guide/mm/transhuge.html">transparent huge
pages</a> (THP). This can further speed up programs, possibly at the cost of
higher memory usage.</p>
<p>Do this by setting the <code>MALLOC_CONF</code> environment variable (or perhaps
<a href="https://github.com/tikv/jemallocator/issues/65"><code>_RJEM_MALLOC_CONF</code></a>) appropriately before building your program, for example:</p>
<pre><code class="language-bash">MALLOC_CONF="thp:always,metadata_thp:always" cargo build --release
</code></pre>
<p>The system running the compiled program also has to be configured to support
THP. See <a href="https://kobzol.github.io/rust/rustc/2023/10/21/make-rust-compiler-5percent-faster.html">this blog post</a> for more details.</p>
<h4 id="mimalloc"><a class="header" href="#mimalloc">mimalloc</a></h4>
<p>Another alternative allocator that works on many platforms is <a href="https://github.com/microsoft/mimalloc">mimalloc</a>,
usable via the <a href="https://crates.io/crates/mimalloc"><code>mimalloc</code></a> crate. To use it, add a dependency to your
<code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
mimalloc = "0.1"
</code></pre>
<p>Then add the following to your Rust code, e.g. at the top of <code>src/main.rs</code>:</p>
<pre><code class="language-rust ignore">#[global_allocator]
static GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;</code></pre>
<h3 id="cpu-specific-instructions"><a class="header" href="#cpu-specific-instructions">CPU Specific Instructions</a></h3>
<p>If you do not care about the compatibility of your binary on older (or other
types of) processors, you can tell the compiler to generate the newest (and
potentially fastest) instructions specific to a <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu">certain CPU architecture</a>,
such as AVX SIMD instructions for x86-64 CPUs.</p>
<p>To request these instructions from the command line, use the <code>-C target-cpu=native</code> flag. For example:</p>
<pre><code class="language-bash">RUSTFLAGS="-C target-cpu=native" cargo build --release
</code></pre>
<p>Alternatively, to request these instructions from a <a href="https://doc.rust-lang.org/cargo/reference/config.html"><code>config.toml</code></a> file (for
one or more projects), add these lines:</p>
<pre><code class="language-toml">[build]
rustflags = ["-C", "target-cpu=native"]
</code></pre>
<p>This can improve runtime speed, especially if the compiler finds vectorization
opportunities in your code.</p>
<p>If you are unsure whether <code>-C target-cpu=native</code> is working optimally, compare
the output of <code>rustc --print cfg</code> and <code>rustc --print cfg -C target-cpu=native</code>
to see if the CPU features are being detected correctly in the latter case. If
not, you can use <code>-C target-feature</code> to target specific features.</p>
<h3 id="profile-guided-optimization"><a class="header" href="#profile-guided-optimization">Profile-guided Optimization</a></h3>
<p>Profile-guided optimization (PGO) is a compilation model where you compile
your program, run it on sample data while collecting profiling data, and then
use that profiling data to guide a second compilation of the program. This can
improve runtime speed by 10% or more.
<a href="https://blog.rust-lang.org/inside-rust/2020/11/11/exploring-pgo-for-the-rust-compiler.html"><strong>Example 1</strong></a>,
<a href="https://github.com/rust-lang/rust/pull/96978"><strong>Example 2</strong></a>.</p>
<p>It is an advanced technique that takes some effort to set up, but is worthwhile
in some cases. See the <a href="https://doc.rust-lang.org/rustc/profile-guided-optimization.html">rustc PGO documentation</a> for details. Also, the
<a href="https://github.com/Kobzol/cargo-pgo"><code>cargo-pgo</code></a> command makes it easier to use PGO (and <a href="https://github.com/llvm/llvm-project/tree/main/bolt">BOLT</a>, which is similar)
to optimize Rust binaries.</p>
<p>Unfortunately, PGO is not supported for binaries hosted on crates.io and
distributed via <code>cargo install</code>, which limits its usability.</p>
<h2 id="minimizing-binary-size"><a class="header" href="#minimizing-binary-size">Minimizing Binary Size</a></h2>
<p>The following build configuration options are designed primarily to minimize
binary size. Their effects on runtime speed vary.</p>
<h3 id="optimization-level"><a class="header" href="#optimization-level">Optimization Level</a></h3>
<p>You can request an <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#opt-level">optimization level</a> that aims to minimize binary size by
adding these lines to the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[profile.release]
opt-level = "z"
</code></pre>
<p>This may also reduce runtime speed.</p>
<p>An alternative is <code>opt-level = "s"</code>, which targets minimal binary size a little
less aggressively. Compared to <code>opt-level = "z"</code>, it allows <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#inline-threshold">slightly more
inlining</a> and also the vectorization of loops.</p>
<h3 id="abort-on-panic"><a class="header" href="#abort-on-panic">Abort on <code>panic!</code></a></h3>
<p>If you do not need to unwind on panic, e.g. because your program doesn’t use
<a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>, you can tell the compiler to simply <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#panic">abort on panic</a>. On
panic, your program will still produce a backtrace.</p>
<p>This might reduce binary size and increase runtime speed slightly, and may even
reduce compile times slightly. Add these lines to the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[profile.release]
panic = "abort"
</code></pre>
<h3 id="strip-symbols"><a class="header" href="#strip-symbols">Strip Symbols</a></h3>
<p>You can tell the compiler to <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#strip">strip</a> symbols from a release build by adding
these lines to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.release]
strip = "symbols"
</code></pre>
<p><a href="https://github.com/nnethercote/counts/commit/53cab44cd09ff1aa80de70a6dbe1893ff8a41142"><strong>Example</strong></a>.</p>
<p>However, stripping symbols may make your compiled program more difficult to
debug and profile. For example, if a stripped program panics, the backtrace
produced may contain less useful information than normal. The exact effects
depend on the platform.</p>
<p>Debug info does not need to be stripped from release builds. By default, debug
info is not generated for local release builds, and debug info for the standard
library has been stripped automatically in release builds <a href="https://blog.rust-lang.org/2024/03/21/Rust-1.77.0.html#enable-strip-in-release-profiles-by-default">since Rust 1.77</a>.</p>
<h3 id="other-ideas"><a class="header" href="#other-ideas">Other Ideas</a></h3>
<p>For more advanced binary size minimization techniques, consult the
comprehensive documentation in the excellent <a href="https://github.com/johnthagen/min-sized-rust"><code>min-sized-rust</code></a> repository.</p>
<h2 id="minimizing-compile-times"><a class="header" href="#minimizing-compile-times">Minimizing Compile Times</a></h2>
<p>The following build configuration options are designed primarily to minimize
compile times.</p>
<h3 id="linking"><a class="header" href="#linking">Linking</a></h3>
<p>A big part of compile time is actually linking time, particularly when
rebuilding a program after a small change. It is possible to select a faster
linker than the default one.</p>
<p>One option is <a href="https://lld.llvm.org/">lld</a>, which is available on Linux and Windows. To specify lld
from the command line, use the <code>-C link-arg=-fuse-ld=lld</code> flag. For example:</p>
<pre><code class="language-bash">RUSTFLAGS="-C link-arg=-fuse-ld=lld" cargo build --release
</code></pre>
<p>Alternatively, to specify lld from a <a href="https://doc.rust-lang.org/cargo/reference/config.html"><code>config.toml</code></a> file (for one or more
projects), add these lines:</p>
<pre><code class="language-toml">[build]
rustflags = ["-C", "link-arg=-fuse-ld=lld"]
</code></pre>
<p>lld is not fully supported for use with Rust, but it should work for most use
cases on Linux and Windows. There is a <a href="https://github.com/rust-lang/rust/issues/39915#issuecomment-618726211">GitHub Issue</a> tracking full support for
lld.</p>
<p>Another option is <a href="https://github.com/rui314/mold">mold</a>, which is currently available on Linux.
Simply substitute <code>mold</code> for <code>lld</code> in the instructions above. mold is often
faster than lld.
<a href="https://davidlattimore.github.io/posts/2024/02/04/speeding-up-the-rust-edit-build-run-cycle.html"><strong>Example</strong></a>.
It is also much newer and may not work in all cases.</p>
<p>Unlike the other options in this chapter, there are no trade-offs here!
Alternative linkers can be dramatically faster, without any downsides.</p>
<h3 id="disable-debug-info-generation"><a class="header" href="#disable-debug-info-generation">Disable Debug Info Generation</a></h3>
<p>Although release builds give the best performance, many people use dev builds
while developing because they build more quickly. If you use dev builds but
don’t often use a debugger, consider disabling debuginfo. This can improve dev
build times significantly, by as much as 20-40%.
<a href="https://kobzol.github.io/rust/rustc/2025/05/20/disable-debuginfo-to-improve-rust-compile-times.html"><strong>Example.</strong></a></p>
<p>To disable debug info generation, add these lines to the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[profile.dev]
debug = false
</code></pre>
<p>Note that this means that stack traces will not contain line information. If
you want to keep that line information, but do not require full information for
the debugger, you can use <code>debug = "line-tables-only"</code> instead, which still
gives most of the compile time benefits.</p>
<h3 id="experimental-parallel-front-end"><a class="header" href="#experimental-parallel-front-end">Experimental Parallel Front-end</a></h3>
<p>If you use nightly Rust, you can enable the experimental <a href="https://blog.rust-lang.org/2023/11/09/parallel-rustc.html">parallel front-end</a>.
It may reduce compile times at the cost of higher compile-time memory usage. It
won’t affect the quality of the generated code.</p>
<p>You can do that by adding <code>-Zthreads=N</code> to RUSTFLAGS, for example:</p>
<pre><code class="language-bash">RUSTFLAGS="-Zthreads=8" cargo build --release
</code></pre>
<p>Alternatively, to enable the parallel front-end from a <a href="https://doc.rust-lang.org/cargo/reference/config.html"><code>config.toml</code></a> file (for
one or more projects), add these lines:</p>
<pre><code class="language-toml">[build]
rustflags = ["-Z", "threads=8"]
</code></pre>
<p>Values other than <code>8</code> are possible, but that is the number that tends to give
the best results.</p>
<p>In the best cases, the experimental parallel front-end reduces compile times by
up to 50%. But the effects vary widely and depend on the characteristics of the
code and its build configuration, and for some programs there is no compile
time improvement.</p>
<h3 id="cranelift-codegen-back-end"><a class="header" href="#cranelift-codegen-back-end">Cranelift Codegen Back-end</a></h3>
<p>If you use nightly Rust you can enable the Cranelift codegen back-end on <a href="https://github.com/rust-lang/rustc_codegen_cranelift#platform-support">some
platforms</a>. It may reduce compile times at the cost of lower quality generated
code, and therefore is recommended for dev builds rather than release builds.</p>
<p>First, install the back-end with this <code>rustup</code> command:</p>
<pre><code class="language-bash">rustup component add rustc-codegen-cranelift-preview --toolchain nightly
</code></pre>
<p>To select Cranelift from the command line, use the
<code>-Zcodegen-backend=cranelift</code> flag. For example:</p>
<pre><code class="language-bash">RUSTFLAGS="-Zcodegen-backend=cranelift" cargo +nightly build
</code></pre>
<p>Alternatively, to specify Cranelift from a <a href="https://doc.rust-lang.org/cargo/reference/config.html"><code>config.toml</code></a> file (for one or
more projects), add these lines:</p>
<pre><code class="language-toml">[unstable]
codegen-backend = true

[profile.dev]
codegen-backend = "cranelift"
</code></pre>
<p>For more information, see the <a href="https://github.com/rust-lang/rustc_codegen_cranelift">Cranelift documentation</a>.</p>
<h2 id="custom-profiles"><a class="header" href="#custom-profiles">Custom profiles</a></h2>
<p>In addition to the <code>dev</code> and <code>release</code> profiles, Cargo supports <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#custom-profiles">custom
profiles</a>. It might be useful, for example, to create a custom profile halfway
between <code>dev</code> and <code>release</code> if you find the runtime speed of dev builds
insufficient and the compile times of release builds too slow for everyday
development.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>There are many choices to be made when it comes to build configurations. The
following points summarize the above information into some recommendations.</p>
<ul>
<li>If you want to maximize runtime speed, consider all of the following:
<code>codegen-units = 1</code>, <code>lto = "fat"</code>, an alternative allocator, and <code>panic = "abort"</code>.</li>
<li>If you want to minimize binary size, consider <code>opt-level = "z"</code>,
<code>codegen-units = 1</code>, <code>lto = "fat"</code>, <code>panic = "abort"</code>, and <code>strip = "symbols"</code>.</li>
<li>In either case, consider <code>-C target-cpu=native</code> if broad architecture support
is not needed, and <code>cargo-pgo</code> if it works with your distribution mechanism.</li>
<li>Always use a faster linker if you are on a platform that supports it, because
there are no downsides to doing so.</li>
<li>Use <code>cargo-wizard</code> if you need additional help with these choices.</li>
<li>Benchmark all changes, one at a time, to ensure they have the expected
effects.</li>
</ul>
<p>Finally, <a href="https://github.com/rust-lang/rust/issues/103595">this issue</a> tracks the evolution of the Rust compiler’s own build
configuration. The Rust compiler’s build system is stranger and more complex
than that of most Rust programs. Nonetheless, this issue may be instructive in
showing how build configuration choices can be applied to a large program.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="benchmarking.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="linting.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="benchmarking.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="linting.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
